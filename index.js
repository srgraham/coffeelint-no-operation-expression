// Generated by CoffeeScript 1.10.0
(function() {
  var NoOperationExpression, cloneStack, dumpStack, getNodeType, var_skip_arr;

  getNodeType = function(node) {
    return node.constructor.name;
  };

  cloneStack = function(stack) {
    var out;
    out = [];
    stack.forEach(function(val) {
      out.push(val);
    });
    return out;
  };

  dumpStack = function(stack) {
    var i, j, len, out;
    out = [];
    for (j = 0, len = stack.length; j < len; j++) {
      i = stack[j];
      out.push(getNodeType(i));
    }
    return out;
  };

  var_skip_arr = ['expect', 'assert', 'should'];

  module.exports = NoOperationExpression = (function() {
    function NoOperationExpression() {}

    NoOperationExpression.prototype.rule = {
      name: 'no_operation_expression',
      level: 'error',
      message: 'Useless value. No expression.',
      description: 'Finds instances where there\'s some code that doesn\'t do anything.\nThis could mean a variable, string, or number on a line with no assignment or calls happening to it.\nEx: Any of these statements on a line by itself\n  5\n  \'stuff\'\n  obj\n\nBy themselves, they don\'t do anything at all. They\'re likely a development oversight\nThe chai variables "expect", "assert", and "should" bypass this rule\n  since they have __getter__ magic happening in them.'
    };

    NoOperationExpression.prototype.lintAST = function(node, astApi) {
      this.astApi = astApi;
      this.lintNode(node, []);
      node.eachChild((function(_this) {
        return function(child) {
          _this.lintBodyChild(child);
        };
      })(this));
    };

    NoOperationExpression.prototype.lintNode = function(node, stack) {
      var body_key, body_keys, j, last_node, len, node_type;
      node_type = getNodeType(node);
      stack = cloneStack(stack);
      stack.push(node);
      switch (node_type) {
        case 'Class':
        case 'Parens':
          break;
        default:
          body_keys = ['body', 'elseBody'];
          for (j = 0, len = body_keys.length; j < len; j++) {
            body_key = body_keys[j];
            if (node[body_key]) {
              if (['If', 'Switch'].indexOf(node_type) !== -1) {
                if (getNodeType(stack[stack.length - 2]) === 'Assign') {
                  break;
                }
              }
              last_node = null;
              switch (node_type) {
                case 'Code':
                  last_node = node[body_key].lastNonComment(node[body_key].expressions);
              }
              node[body_key].eachChild((function(_this) {
                return function(child) {
                  if (child !== last_node) {
                    _this.lintBodyChild(child);
                  }
                };
              })(this));
            }
          }
      }
      node.eachChild((function(_this) {
        return function(child) {
          _this.lintNode(child, stack);
        };
      })(this));
    };

    NoOperationExpression.prototype.lintBodyChild = function(node) {
      if (this.isBadChild(node)) {
        this.throwError(node);
      }
    };

    NoOperationExpression.prototype.isBadChild = function(node) {
      var node_type, ref, ref1, ref2, var_name;
      node_type = getNodeType(node);
      switch (node_type) {
        case 'Code':
          return true;
        case 'Value':
          var_name = (ref = node.base) != null ? (ref1 = ref.variable) != null ? (ref2 = ref1.base) != null ? ref2.value : void 0 : void 0 : void 0;
          if (var_skip_arr.indexOf(var_name) !== -1) {
            return false;
          }
          return true;
      }
      return false;
    };

    NoOperationExpression.prototype.throwError = function(node) {
      var err;
      err = this.astApi.createError({
        lineNumber: node.locationData.first_line + 1
      });
      this.errors.push(err);
    };

    return NoOperationExpression;

  })();

}).call(this);

//# sourceMappingURL=index.js.map
